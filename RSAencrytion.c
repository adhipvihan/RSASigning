/* Author: Adhip Vihan */

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

void upper_string(char* s) {
   int c = 0;
   while (c<strlen(s)) {
      if (s[c] >= 'a' && s[c] <= 'z') {
        s[c] -= 32;
     }
     c++;
   }
}


/*Function to Generate Public and Private Key Pairs. Given that the Private key is already
  generated using the Function generateKey()
*/
void genPair(){

    int pid;
    int i;
    for(i=0;i<2;i++){

        pid = fork();

        if(pid<=0){

            if(i==0){
                char *genKey[]  = {"openssl","rsa","-in","rsaprivatekey1024.pem","-out","rsapublickey1024.pem","-outform","PEM","-pubout",NULL};
                execv("/usr/bin/openssl", genKey); 
            }
            else if(i==1){
                char *genKey2[]  = {"openssl","rsa","-in","rsaprivatekey2048.pem","-out","rsapublickey2048.pem","-outform","PEM","-pubout",NULL};
                execv("/usr/bin/openssl", genKey2); 
            }
        }else{
           waitpid(pid,NULL, 0);
        }

    }
}

/*Function to Generate Private Key */

int generateKey(){
    int pid;
    int i;


    for(i=0;i<2;i++){

        pid = fork();

        if(pid<=0){

            if(i==0){
                char *genKey1[]  = {"openssl","genrsa","-out","rsaprivatekey1024.pem","1024",NULL};  
                execv("/usr/bin/openssl", genKey1);
            }else if(i==1){
                char *genKey2[]  = {"openssl","genrsa","-out","rsaprivatekey2048.pem","2048",NULL}; 
                execv("/usr/bin/openssl", genKey2);
            }
        }else{
           waitpid(pid,NULL, 0);
        }

    }

       return 0; 

}

/*Function to sign the msgs using the private public key generated by genPair()
*/

void encryption_helper(char* digest,char* prvKey,char * keyLen){
    int i;
    int pid;
    char hashFunction[10];
    char plainText[10];
    char cipher[40];

    memset(hashFunction,0,10);
	sprintf(hashFunction, "-%s", digest);
    
    upper_string(digest);
    char folder[20];
    memset(folder,0,20);
    sprintf(folder, "%s%s", keyLen,digest);

    clock_t start = clock();
    for(i=1;i<=10;i++){
        memset(plainText,0,10);
	    sprintf(plainText, "msg/msg.%d", i);

        memset(cipher,0,40);
	    sprintf(cipher, "Output/%s/cipher.%d",folder,i);

        pid = fork();

        if(pid<=0){
            char *com[]  = {"openssl","dgst",hashFunction,"-sign",prvKey,"-out",cipher,plainText,NULL};
            execv("/usr/bin/openssl", com);
        }else{
           waitpid(pid,NULL, 0);
        }
    }

        clock_t stop = clock();
        double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC;
        printf("\nTime elapsed in ms: %f", elapsed);   
}


/*Function to Verify the msgs using the public key generated by genPair()
*/

   void decryption_helper(char *digest,char *pubKey,char * keyLen){
        int i=1;
        int pid;
        char hashFunction[10];
        char plainText[10];
        char cipher[40];

        memset(hashFunction,0,10);
	    sprintf(hashFunction, "-%s", digest);

        upper_string(digest);
        char folder[20];
        memset(folder,0,20);
        sprintf(folder, "%s%s", keyLen,digest);

        clock_t start = clock();

    for(i;i<=10;i++){
        memset(plainText,0,10);
	    sprintf(plainText, "msg/msg.%d", 1);

        memset(cipher,0,40);
	    sprintf(cipher, "Output/%s/cipher.%d",folder,1);

        pid = fork();

        if(pid<=0){
            char *com[]  = {"openssl","dgst",hashFunction,"-verify",pubKey,"-signature",cipher,plainText,NULL};
            execv("/usr/bin/openssl", com);
        }else{
            waitpid(pid,NULL, 0);
        }
   }

        clock_t stop = clock();
        double elapsed = (double)(stop - start) * 1000.0 / CLOCKS_PER_SEC;
        printf("\nTime elapsed in ms: %f", elapsed);
}


int main(){

generateKey();
genPair();
    char hashFun1[10] = "sha1";
    char hashFun256[10] = "sha256";
    int i;
    for(i=0;i<5;i++){
        encryption_helper(hashFun1,"rsaprivatekey1024.pem","1024");
        decryption_helper(hashFun1,"rsapublickey1024.pem","1024");
        encryption_helper(hashFun256,"rsaprivatekey1024.pem","1024");
        decryption_helper(hashFun256,"rsapublickey1024.pem","1024");
        encryption_helper(hashFun1,"rsaprivatekey2048.pem","2048");
        decryption_helper(hashFun1,"rsapublickey2048.pem","2048");
        encryption_helper(hashFun256,"rsaprivatekey2048.pem","2048");
        decryption_helper(hashFun256,"rsapublickey2048.pem","2048");
    }
    return 0;
}
